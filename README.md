# LogSentry

1) Цель проекта

Создать лёгкую “мини-SIEM” систему, которая собирает логи из нескольких источников, нормализует их в единый формат событий, сохраняет в локальное хранилище, выполняет детектирование типовых инцидентов (brute-force, сканирование, всплески ошибок) и предоставляет веб-дашборд для просмотра событий, алертов и базовой аналитики.

Проект ориентирован на быстрое внедрение и демонстрацию ценности ИБ без тяжёлой инфраструктуры (без ELK/Splunk), с возможностью дальнейшего расширения.

⸻

2) Что система делает (функциональные возможности)

2.1 Сбор данных (Log Collection)
Система читает события из файлов логов в режиме, близком к real-time:
 • Nginx access.log (HTTP запросы, статусы, IP, user-agent, URL)
 • Linux auth.log (SSH логины, неуспешные попытки, пользователи, IP)
 • (опционально) Application logs (JSON Lines) — если приложение пишет структурированные события

Сбор реализуется через “tail-подобный” механизм: система отслеживает изменения файлов, читает новые строки, поддерживает восстановление после перезапуска.

2.2 Нормализация (Normalization)
Любая сырая строка лога приводится к единому Event формату, чтобы:
 • хранить разные источники в одной таблице
 • строить общие фильтры и графики
 • писать детекты один раз под общий формат

Единый формат события (Event) включает:
 • ts — timestamp события
 • source — источник (nginx_access, auth_log, app_json)
 • host — хост/сервер
 • event_type — тип события (http_request, ssh_auth_fail, ssh_auth_ok, …)
 • src_ip — IP источника
 • user — пользователь (если есть)
 • action — действие (GET/POST/ssh_login/…)
 • resource — URL/path/ресурс
 • status — код/результат (например 200/401 или success/fail)
 • severity — уровень важности (info/warn/high)
 • msg — человекочитаемое сообщение
 • raw — оригинальная строка лога (для расследования)

2.3 Хранение (Storage)
Для MVP используется SQLite, чтобы:
 • запускаться “из коробки” без внешней БД
 • быстро показать результат
 • обеспечить удобный поиск и агрегаты

Хранилище содержит:
 • events — все нормализованные события
 • alerts — алерты детектов
 • state — состояние чтения файлов (позиции, offsets), чтобы продолжать после рестарта

Добавляются индексы по времени, IP, источнику, типу события.

2.4 Детектирование (Detections / Rules)
Система запускает набор правил (конфигурируемых порогами в config.yaml) и создаёт alerts.

MVP-правила:
 1. Brute-force / Password guessing
 • N неудачных попыток логина за T минут по src_ip и/или user
 • источники: auth.log, а также /login 401 из nginx
 2. Scanning / Recon
 • много уникальных resource за короткое время с одного IP
 • характерно для перебора путей и “поиска админок”
 3. Spikes 401/403
 • резкий всплеск отказов доступа (возможна атака или сломанный клиент)
 • сравнение с простым baseline/порогами
 4. Suspicious User-Agent
 • пустые/очень короткие UA, “curl”, “python-requests” и т.п.

Каждый alert содержит:
 • время
 • правило/тип
 • severity
 • ключ (IP/пользователь)
 • краткое описание
 • ссылки/выборку событий, из которых сформирован алерт

2.5 Веб-интерфейс (Dashboard)
Мини-веб-дашборд позволяет:
 • видеть общую картину (события за 24ч, топ IP, топ URL, график 4xx/5xx)
 • просматривать алерты (фильтры по severity/типу/периоду)
 • делать поиск событий по IP/пользователю/пути/статусу/времени
 • быстро переходить от алерта к соответствующим событиям (triage)

Технологии: FastAPI + HTML templates + Chart.js.

⸻

3) Архитектура (как это работает внутри)

Пайплайн:
 1. Collector читает новые строки логов
 2. Parser/Normalizer превращает их в Event
 3. Storage пишет Event в SQLite
 4. Detections engine периодически читает события и создаёт Alerts
 5. Dashboard/API показывает события и алерты пользователю

Принцип: каждый модуль максимально независим, общая точка стыка — модель Event.

⸻

4) Конфигурирование

Через config.yaml можно задавать:
 • какие источники логов включены и где лежат файлы
 • формат парсинга nginx (pattern)
 • пороги детектов (N/T, окна времени, whitelist)
 • расписание запуска детектов
 • параметры retention (сколько хранить событий)

⸻
5) Сценарий демонстрации (что показать на защите)
 1. Запускаем систему локально/в Docker
 2. Подкидываем тестовые логи (или запускаем генератор)
 3. На дашборде видно:
 • график роста 401/403
 • топ IP “атакера”
 • алерт brute-force на конкретный IP
 4. Открываем алерт → видим связанные события → показываем исходные строки логов
 5. Меняем порог в config.yaml → детект начинает реагировать иначе (показываем гибкость)

⸻

6) Ограничения MVP (что сознательно не делаем сразу)
 • нет корреляции “как в Splunk” на десятки источников
 • нет распределённого сбора (агентов) — только локальные файлы
 • нет ML/сложной аномалистики (только правила)
 • нет ролевой модели пользователей (внутренний инструмент)

⸻

7) Потенциал развития (после MVP)
 • смена SQLite на ClickHouse/Elastic
 • отправка алертов в Telegram/Slack/email
 • поддержка Syslog/Windows events
 • enrichment IP (ASN/Geo), интеграции с threat intel
 • более умная корреляция инцидентов

⸻

8) Итог

Проект Mini-SIEM — это компактная система мониторинга безопасности, которая:
 • даёт централизованный обзор логов
 • позволяет быстро находить типовые атаки
 • имеет визуальный дашборд для анализа
 • легко разворачивается и расширяется
